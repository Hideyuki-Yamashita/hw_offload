/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
 */

#ifndef _SPPWK_TH_VF_DEPS_H_
#define _SPPWK_TH_VF_DEPS_H_

#include <rte_malloc.h>
#include <rte_hash.h>
#include "cmd_utils.h"
#include "cmd_parser.h"
#include "cmd_res_formatter.h"
#include "shared/secondary/common.h"

#define SPPWK_PROC_TYPE "vf"

/* Number of VLAN ID */
#define NOF_VLAN 4096

/* Num of entries of ops_list in vf_cmd_runner.c. */
#define NOF_STAT_OPS 8

/* Classifier for MAC addresses. */
struct mac_classifier {
	struct rte_hash *cls_tbl;  /* Hash table for MAC classification. */
	int nof_cls_ports;  /* Num of ports classified validly. */
	int cls_ports[RTE_MAX_ETHPORTS];  /* Ports for classification. */
	int default_cls_idx;  /* Default index for classification. */
};

/* Attirbutes of port for classification. */
/* TODO(yasufum) confirm what is `iface_no_global`. */
struct cls_port_info {
	enum port_type iface_type;
	int iface_no;   /* Index of ports handled by classifier. */
	int iface_no_global;  /* ID for interface generated by spp_vf */
	uint16_t ethdev_port_id;  /* Ethdev port ID. */
	uint16_t nof_pkts;  /* Number of packets in pkts[]. */
	struct rte_mbuf *pkts[MAX_PKT_BURST];  /* packets to be classified. */
};

/* classifier component information */
struct cls_comp_info {
	char name[STR_LEN_NAME];  /* component name */
	int mac_addr_entry;  /* mac address entry flag */
	struct mac_classifier *mac_clfs[NOF_VLAN];  /* classifiers per VLAN. */
	int nof_tx_ports;  /* Number of TX ports info entries. */
	/* Classifier has one RX port and several TX ports. */
	struct cls_port_info rx_port_i;  /* RX port info classified. */
	struct cls_port_info tx_ports_i[RTE_MAX_ETHPORTS];  /* TX info. */
};

int add_core(const char *name, char **output,
		void *tmp __attribute__ ((unused)));

/* Release instance of mac classifier. */
static inline void
free_mac_classifier(struct mac_classifier *mac_clf)
{
	if (mac_clf == NULL)
		return;
	if (mac_clf->cls_tbl != NULL)
		rte_hash_free(mac_clf->cls_tbl);
	rte_free(mac_clf);
}

int exec_one_cmd(const struct sppwk_cmd_attrs *cmd);

/**
 * Update classifier info.
 *
 * @param wk_comp_info Pointer to internal data of classifier.
 * @retval SPPWK_RET_OK If succeeded.
 * @retval SPPWK_RET_NG If failed.
 */
int update_classifier(struct sppwk_comp_info *wk_comp_info);

/**
 * Update forwarder info.
 *
 * @param component Pointer to data of forwarder and merger.
 * @retval SPPWK_RET_OK If succeeded.
 * @retval SPPWK_RET_NG If failed.
 */
int update_forwarder(struct sppwk_comp_info *wk_comp_info);

void init_classifier_info(int component_id);

/**
 * Activate temporarily stored component info while flushing.
 *
 * @param[in] p_comp_info Info of component.
 * @param[in] p_change_comp Pointer to a set of Flags for udpated component.
 * @retval SPPWK_RET_OK If succeeded.
 * @retval SPPWK_RET_NG If failed.
 */
int update_comp_info(struct sppwk_comp_info *p_comp_info, int *p_change_comp);

enum sppwk_worker_type get_comp_type_from_str(const char *type_str);

int get_status_ops(struct cmd_res_formatter_ops *ops_list);

int get_client_id(void);

#endif  /* _SPPWK_TH_VF_DEPS_H_ */
